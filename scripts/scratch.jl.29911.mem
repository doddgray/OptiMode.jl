        - ##
        - # import Base: +, -, zero
        - import Base.Iterators
        - using LinearAlgebra, StaticArrays, Zygote
        - 
        - # struct Point
        - #   x::Float64
        - #   y::Float64
        - # end
        - #
        - # width(p::Point) = p.x
        - # height(p::Point) = p.y
        - #
        - # a::Point + b::Point = Point(width(a) + width(b), height(a) + height(b))
        - # a::Point - b::Point = Point(width(a) - width(b), height(a) - height(b))
        - # dist(p::Point) = sqrt(width(p)^2 + height(p)^2)
        - #
        - # ##
        - 
        - @Zygote.adjoint (T :: Type{<:SVector})(xs :: Number ...) = T(xs...), dv -> (nothing, dv...)
        - @Zygote.adjoint (T :: Type{<:SVector})(x :: AbstractVector) = T(x), dv -> (nothing, dv)
        - 
        - @Zygote.adjoint enumerate(xs) = enumerate(xs), diys -> (map(last, diys),)
        - 
        - _ndims(::Base.HasShape{d}) where {d} = d
        - _ndims(x) = Base.IteratorSize(x) isa Base.HasShape ? _ndims(Base.IteratorSize(x)) : 1
        - 
        - @Zygote.adjoint function Iterators.product(xs...)
        -                     d = 1
        -                     Iterators.product(xs...), dy -> ntuple(length(xs)) do n
        -                         nd = _ndims(xs[n])
        -                         dims = ntuple(i -> i<d ? i : i+nd, ndims(dy)-nd)
        -                         d += nd
        -                         func = sum(y->y[n], dy; dims=dims)
        -                         ax = axes(xs[n])
        -                         reshape(func, ax)
        -                     end
        -                 end
        - 
        - # @Zygote.adjoint width(p::Point) = p.x, x̄ -> (Point(x̄, 0),)
        - # @Zygote.adjoint height(p::Point) = p.y, ȳ -> (Point(0, ȳ),)
        - # @Zygote.adjoint Point(a, b) = Point(a, b), p̄ -> (p̄.x, p̄.y)
        - # zero(::Point) = Point(0, 0)
        - 
        - # ##
        - # xs = Point.(1:5, 5:9)
        - #
        - # function something(xs)
        - #     sum([ width(p1) + height(p2) for p1 in xs, p2 in xs ])
        - # end
        - #
        - # gradient(something, xs)
        - 
        - function sum2(op,arr)
        -     return sum(op,arr)
        - end
        - 
        - function sum2adj( Δ, op, arr )
        -     n = length(arr)
        -     g = x->Δ*Zygote.gradient(op,x)[1]
        -     return ( nothing, map(g,arr))
        - end
        - 
        - Zygote.@adjoint function sum2(op,arr)
        -     return sum2(op,arr),Δ->sum2adj(Δ,op,arr)
        - end
        - 
        - Zygote.refresh()
        - 
        - function KpG(kz::Real,gx::Real,gy::Real,gz::Real)
        - 	# scale = ds.kpG[i,j,k].mag
        - 	kpg = [-gx; -gy; kz-gz]
        - 	mag = sqrt(sum2(abs2,kpg)) # norm(kpg)
        - 	if mag==0
        - 		n = [0.; 1.; 0.] # SVector(0.,1.,0.)
        - 		m = [0.; 0.; 1.] # SVector(0.,0.,1.)
        - 	else
        - 		if kpg[1]==0. && kpg[2]==0.    # put n in the y direction if k+G is in z
        - 			n = [0.; 1.; 0.] #SVector(0.,1.,0.)
        - 		else                                # otherwise, let n = z x (k+G), normalized
        - 			ntemp = [0.; 0.; 1.] × kpg  #SVector(0.,0.,1.) × kpg
        - 			n = ntemp / sqrt(sum2(abs2,ntemp)) # norm(ntemp) #
        - 		end
        - 	end
        - 	# m = n x (k+G), normalized
        - 	mtemp = n × kpg
        - 	m = mtemp / sqrt(sum2(abs2,mtemp)) #norm(mtemp) # sqrt( mtemp[1]^2 + mtemp[2]^2 + mtemp[3]^2 )
        - 	return kpg, mag, m, n
        - end
        - 
        - function KpG2(kz::Float64,gx::Float64,gy::Float64,gz::Float64)
        - 	# scale = ds.kpG[i,j,k].mag
        - 	kpg = SVector{3,Float64}(-gx, -gy, kz-gz)
        - 	mag = norm(kpg)
        - 	if mag==0
        - 		n = SVector{3,Float64}(0.,1.,0.)
        - 		m = SVector{3,Float64}(0.,0.,1.)
        - 	else
        - 		if kpg[1]==0. && kpg[2]==0.    # put n in the y direction if k+G is in z
        - 			n = SVector{3,Float64}(0.,1.,0.)
        - 		else                                # otherwise, let n = z x (k+G), normalized
        - 			ntemp = SVector{3,Float64}(0.,0.,1.) × kpg
        - 			n = ntemp / norm(ntemp) #
        - 		end
        - 	end
        - 	# m = n x (k+G), normalized
        - 	mtemp = n × kpg
        - 	m = mtemp / norm(mtemp) # sqrt( mtemp[1]^2 + mtemp[2]^2 + mtemp[3]^2 )
        - 	return kpg, mag, m, n
        - end
        - 
        - # kpg, mag, m, n = KpG(1.5,3.5,6.5,0.0)
        - # KpG2(1.5,3.5,6.5,0.0)
        - # KpG(1.5,3.5,6.5,0.0)[2]
        - # KpG2(1.5,3.5,6.5,0.0)[2]
        - # Zygote.gradient((kz,gx,gy,gz)->KpG(kz,gx,gy,gz)[2],1.5,3.5,6.5,0.0)
        - # Zygote.gradient((kz,gx,gy,gz)->KpG2(kz,gx,gy,gz)[2],1.5,3.5,6.5,0.0)
        - 
        - function ∇KpG2(a,b,c,d)
        0 	Zygote.gradient((kz,gx,gy,gz)->KpG(kz,gx,gy,gz)[2],a,b,c,d)
        - end
        - 
        - function ∇KpG22(a,b,c,d)
      128 	Zygote.gradient((kz::Float64,gx::Float64,gy::Float64,gz::Float64)->KpG2(kz,gx,gy,gz)[2]::Float64,a,b,c,d)
        - end
        - 
        - #
        - # @btime ∇KpG2(1.5,3.5,6.5,0.0)
        - # @btime ∇KpG22(1.5,3.5,6.5,0.0)
        - 
        - ∇KpG2(1.5,3.5,6.5,0.0)
        - ∇KpG22(1.5,3.5,6.5,0.0)
